#ifndef SDK_IVTFTEXTURE_HPP
#define SDK_IVTFTEXTURE_HPP

#include "ImageFormat.hpp"
#include "CUtl/Buffer.hpp"

MAKE_CENUM_Q(LookDir, i32,
	DOWN_X, 0,
	DOWN_NEGX, 1,
	DOWN_Y, 2,
	DOWN_NEGY, 3,
	DOWN_Z, 4,
	DOWN_NEGZ, 5);

MAKE_CENUM_Q(CompiledVtfFlags, i32,
	// Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE	               , 0x00000001,
	TEXTUREFLAGS_TRILINEAR		               , 0x00000002,
	TEXTUREFLAGS_CLAMPS			               , 0x00000004,
	TEXTUREFLAGS_CLAMPT			               , 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC	               , 0x00000010,
	TEXTUREFLAGS_HINT_DXT5		               , 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED				   , 0x00000040,
	TEXTUREFLAGS_NORMAL			               , 0x00000080,
	TEXTUREFLAGS_NOMIP			               , 0x00000100,
	TEXTUREFLAGS_NOLOD			               , 0x00000200,
	TEXTUREFLAGS_ALL_MIPS			           , 0x00000400,
	TEXTUREFLAGS_PROCEDURAL		               , 0x00000800,

	// These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA	               , 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA	               , 0x00002000,

	// Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP			               , 0x00004000,
	TEXTUREFLAGS_RENDERTARGET	               , 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET	           , 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE               , 0x00020000,
	TEXTUREFLAGS_SINGLECOPY		               , 0x00040000,
	
	TEXTUREFLAGS_PRE_SRGB					   , 0x00080000, //SRGB correction has already been applied to this texture.

	TEXTUREFLAGS_UNUSED_00100000		   , 0x00100000,
	TEXTUREFLAGS_UNUSED_00200000           , 0x00200000,
	TEXTUREFLAGS_UNUSED_00400000           , 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER                 , 0x00800000,

	TEXTUREFLAGS_UNUSED_01000000           , 0x01000000,

	TEXTUREFLAGS_CLAMPU                        , 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE                 , 0x04000000,	// Usable as a vertex texture
	TEXTUREFLAGS_SSBUMP                        , 0x08000000,			

	TEXTUREFLAGS_UNUSED_10000000           , 0x10000000,

	TEXTUREFLAGS_BORDER						   , 0x20000000,	// Clamp to border color on all texture coordinates

	TEXTUREFLAGS_UNUSED_40000000		   , 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000		   , 0x80000000,
);

struct VtfProcessingOptions
{
	u32 cbSize; // Set to sizeof( VtfProcessingOptions )

	//
	// Flags0
	//
	MAKE_CENUM_Q(Flags, u32,
		// Have a channel decaying to a given decay goal for the given last number of mips
		DECAY_R, 0x00000001, // Red decays
		DECAY_G, 0x00000002, // Green decays
		DECAY_B, 0x00000004, // Blue decays
		DECAY_A, 0x00000008, // Alpha decays

		DECAY_EXP_R, 0x00000010, // Channel R decays exponentially (otherwise linearly)
		DECAY_EXP_G, 0x00000020, // Channel G decays exponentially (otherwise linearly)
		DECAY_EXP_B, 0x00000040, // Channel B decays exponentially (otherwise linearly)
		DECAY_EXP_A, 0x00000080, // Channel A decays exponentially (otherwise linearly)

		NOCOMPRESS, 0x00000100, // Use uncompressed image format
		NORMAL_DUDV, 0x00000200, // dU dV normal map
		FILTER_NICE, 0x00000400, // Use nice filtering
		SRGB_PC_TO_360, 0x00000800, // Perform srgb correction for colormaps

		SET_ALPHA_ONEOVERMIP, 0x00001000, // Alpha  = 1/miplevel
		PREMULT_COLOR_ONEOVERMIP, 0x00002000, // Color *= 1/miplevel
		MIP_ALPHATEST, 0x00004000, // Alpha-tested mip generation
		NORMAL_GA, 0x00008000, // Use Green-Alpha normal compression
		PREMULT_ALPHA_MIPFRACTION, 0x00010000, // Alpha *= miplevel/mipcount
	);

	Flags flags; // A combination of "Flags"

	//
	// Decay settings
	//
	std::array<u8, 4> clrDecayGoal; // Goal colors for R G B A
	std::array<u8, 4> numNotDecayMips; // Number of first mips unaffected by decay (0 means all below mip0)
	std::array<f32, 4> decayExponentBase; // For exponential decay the base number (e.g. 0.75)

	//
	// Alpha fading with mip levels
	//
	u8 fullAlphaAtMipLevel;
	u8 minAlpha;
};

class IVTFTexture : non_constructible
{
public:
	// Initializes the texture and allocates space for the bits
	// In most cases, you shouldn't force the mip count.
	virtual bool Init(i32 width, i32 height, i32 depth, ImageFormat fmt, i32 flags, i32 frameCount, i32 forceMipCount = -1) = 0;

	// Methods to set other texture fields
	virtual void SetBumpScale(f32 flScale) = 0;
	virtual void SetReflectivity(const Vec3& vecReflectivity) = 0;

	// Methods to initialize the low-res image
	virtual void InitLowResImage(i32 width, i32 height, ImageFormat fmt) = 0;

	// set the resource data (for writers). pass size=0 to delete data. if pdata is not null,
	// the resource data will be copied from *pData
	virtual void* SetResourceData(u32 eType, void const* data, std::size_t dataSize) = 0;

	// find the resource data and return a pointer to it. The data pointed to by this pointer will
	// go away when the ivtftexture does. retruns null if resource not present
	virtual void* GetResourceData(u32 eType, std::size_t* dataSize) const = 0;

	// Locates the resource entry info if it's present, easier than crawling array types
	virtual bool HasResourceEntry(u32 eType) const = 0;

	// Retrieve available resource types of this IVTFTextures
	//		arrTypesBuffer			buffer to be filled with resource types available.
	//		numTypesBufferElems		how many resource types the buffer can accomodate.
	// Returns:
	//		number of resource types available (can be greater than "numTypesBufferElems"
	//		in which case only first "numTypesBufferElems" are copied to "arrTypesBuffer")
	virtual u32 GetResourceTypes(u32* arrTypesBuffer, i32 numTypesBufferElems) const = 0;

	// When unserializing, we can skip a certain number of mip levels,
	// and we also can just load everything but the image data
	// NOTE: If you load only the buffer header, you'll need to use the
	// VTFBufferHeaderSize() method below to only read that much from the file
	// NOTE: If you skip mip levels, the height + width of the texture will
	// change to reflect the size of the largest read in mip level
	virtual bool Unserialize(CUtlBuffer& buf, bool headerOnly = false, i32 skipMipLevels = 0) = 0;
	virtual bool Serialize(CUtlBuffer& buf) = 0;

	// These are methods to help with optimization:
	// Once the header is read in, they indicate where to start reading
	// other data (measured from file start), and how many bytes to read....
	virtual void LowResFileInfo(i32* startLocation, i32* sizeInBytes) const = 0;
	virtual void ImageFileInfo(i32 frame, i32 face, i32 mip, i32* startLocation, i32* sizeInBytes) const = 0;
	virtual i32 FileSize(i32 mipSkipCount = 0) const = 0;

	// Attributes...
	virtual i32 Width() const = 0;
	virtual i32 Height() const = 0;
	virtual i32 Depth() const = 0;
	virtual i32 MipCount() const = 0;

	// returns the size of one row of a particular mip level
	virtual i32 RowSizeInBytes(i32 mipLevel) const = 0;

	// returns the size of one face of a particular mip level
	virtual i32 FaceSizeInBytes(i32 mipLevel) const = 0;

	virtual ImageFormat Format() const = 0;
	virtual i32 FaceCount() const = 0;
	virtual i32 FrameCount() const = 0;
	virtual i32 Flags() const = 0;

	virtual float BumpScale() const = 0;

	virtual i32 LowResWidth() const = 0;
	virtual i32 LowResHeight() const = 0;
	virtual ImageFormat LowResFormat() const = 0;

	// NOTE: reflectivity[0] = blue, [1] = greem, [2] = red
	virtual const Vec3& Reflectivity() const = 0;

	virtual bool IsCubeMap() const = 0;
	virtual bool IsNormalMap() const = 0;
	virtual bool IsVolumeTexture() const = 0;

	// Computes the dimensions of a particular mip level
	virtual void ComputeMipLevelDimensions(i32 mipLevel, i32* mipWidth, i32* mipHeight, i32* mipDepth) const = 0;

	// Computes the size (in bytes) of a single mipmap of a single face of a single frame
	virtual i32 ComputeMipSize(i32 mipLevel) const = 0;

	// Computes the size of a subrect (specified at the top mip level) at a particular lower mip level
	virtual void ComputeMipLevelSubRect(Rect2i* srcRect, i32 mipLevel, Rect2i* subRect) const = 0;

	// Computes the size (in bytes) of a single face of a single frame
	// All mip levels starting at the specified mip level are included
	virtual i32 ComputeFaceSize(i32 startingMipLevel = 0) const = 0;

	// Computes the total size (in bytes) of all faces, all frames
	virtual i32 ComputeTotalSize() const = 0;

	// Returns the base address of the image data
	virtual u8* ImageData() = 0;

	// Returns a pointer to the data associated with a particular frame, face, and mip level
	virtual u8* ImageData(i32 frame, i32 face, i32 mipLevel) = 0;

	// Returns a pointer to the data associated with a particular frame, face, mip level, and offset
	virtual u8* ImageData(i32 frame, i32 face, i32 mipLevel, i32 x, i32 y, i32 z = 0) = 0;

	// Returns the base address of the low-res image data
	virtual u8* LowResImageData() = 0;

	// Converts the textures image format. Use IMAGE_FORMAT_DEFAULT
	// if you want to be able to use various tool functions below
	virtual void ConvertImageFormat(ImageFormat fmt, bool bNormalToDUDV, bool bNormalToDXT5GA = false) = 0;

	// NOTE: The following methods only work on textures using the
	// IMAGE_FORMAT_DEFAULT!

	// Generate spheremap based on the current cube faces (only works for cubemaps)
	// The look dir indicates the direction of the center of the sphere
	// NOTE: Only call this *after* cube faces have been correctly
	// oriented (using FixCubemapFaceOrientation)
	virtual void GenerateSpheremap(LookDir lookDir = LookDir::DOWN_Z) = 0;

	// Generate spheremap based on the current cube faces (only works for cubemaps)
	// The look dir indicates the direction of the center of the sphere
	// NOTE: Only call this *after* cube faces have been correctly
	// oriented (using FixCubemapFaceOrientation)
	virtual void GenerateHemisphereMap(u8* sphereMapBitsRGBA, i32 targetWidth, i32 targetHeight, LookDir lookDir, i32 frame) = 0;

	// Fixes the cubemap faces orientation from our standard to the
	// standard the material system needs.
	virtual void FixCubemapFaceOrientation() = 0;

	// Generates mipmaps from the base mip levels
	virtual void GenerateMipmaps() = 0;

	// Put 1/miplevel (1..n) into alpha.
	virtual void PutOneOverMipLevelInAlpha() = 0;

	// Scale alpha by miplevel/mipcount
	virtual void PremultAlphaWithMipFraction() = 0;

	// Computes the reflectivity
	virtual void ComputeReflectivity() = 0;

	// Computes the alpha flags
	virtual void ComputeAlphaFlags() = 0;

	// Generate the low-res image bits
	virtual bool ConstructLowResImage() = 0;

	// Gets the texture all internally consistent assuming you've loaded
	// mip 0 of all faces of all frames
	virtual void PostProcess(bool generateSpheremap, LookDir lookDir = LookDir::DOWN_Z, bool allowFixCubemapOrientation = true, bool loadedMiplevels = false) = 0;

	// Blends adjacent pixels on cubemap borders, since the card doesn't do it. If the texture
	// is S3TC compressed, then it has to do it AFTER the texture has been compressed to prevent
	// artifacts along the edges.
	//
	// If bSkybox is true, it assumes the faces are oriented in the way the engine draws the skybox
	// (which happens to be different from the way cubemaps have their faces).
	virtual void MatchCubeMapBorders(i32 stage, ImageFormat finalFormat, bool skybox) = 0;

	// Sets threshhold values for alphatest mipmapping
	virtual void SetAlphaTestThreshholds(f32 Base, f32 HighFreq) = 0;

	virtual bool IsPreTiled() const = 0;


	// Sets post-processing flags (settings are copied, pointer passed to distinguish between structure versions)
	virtual void SetPostProcessingSettings(VtfProcessingOptions const* pOptions) = 0;
};

#endif // SDK_IVTFTEXTURE_HPP
